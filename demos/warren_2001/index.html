<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warren's Control Law: Moth vs. Pilot</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #2a2a2a;
            --text: #eee;
            --accent: #00d4ff; /* Flow/Path */
            --secondary: #ff9f43; /* Facing/Ego */
            --danger: #ff6b6b; /* Goal */
        }
        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            flex: 1;
            cursor: crosshair;
        }
        #sidebar {
            width: 320px;
            background: var(--panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
        }
        h1 { margin: 0 0 5px 0; font-size: 1.2rem; }
        p { margin: 0; font-size: 0.85rem; opacity: 0.7; line-height: 1.4; }
        
        .control-group {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        label { font-weight: bold; font-size: 0.9rem; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }
        .dot { width: 10px; height: 10px; border-radius: 50%; }
        
        #equation {
            font-family: monospace;
            background: #000;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .eq-ego { color: var(--secondary); }
        .eq-flow { color: var(--accent); }
        
        button {
            padding: 12px;
            background: var(--accent);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
    </style>
</head>
<body>

<canvas id="simCanvas"></canvas>

<div id="sidebar">
    <div>
        <h1>Warren's Control Law</h1>
        <p>Visualizing the battle between "Facing" and "Flow".</p>
    </div>

    <div id="equation">
        Turn = - ( <span class="eq-ego">Facing</span> + <span class="eq-flow">Weight Ã— Path</span> )
    </div>

    <div class="control-group">
        <div class="control-header">
            <label style="color: var(--accent);">Flow Weight (w)</label>
            <span id="val-w">0.0</span>
        </div>
        <input type="range" id="slider-w" min="0" max="10" step="0.1" value="0">
        <p style="margin-top: 8px; font-size: 0.75rem;">
            0 = Blind/Dark (Egocentric)<br>
            10 = High Visibility (Optic Flow)
        </p>
    </div>

    <div class="control-group">
        <div class="control-header">
            <label>Drift</label>
            <span id="val-drift">Right</span>
        </div>
        <input type="range" id="slider-drift" min="-2" max="2" step="0.1" value="0.8">
        <p style="margin-top: 8px; font-size: 0.75rem;">
            Simulates sideways slip or prism effect.
        </p>
    </div>

    <div class="control-group">
        <label>Legend</label>
        <div style="margin-top: 10px;">
            <div class="legend-item">
                <div class="dot" style="background: var(--secondary);"></div>
                <span>Nose Direction (Facing)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: var(--accent);"></div>
                <span>Actual Path (Flow)</span>
            </div>
             <div class="legend-item">
                <div class="dot" style="background: var(--danger);"></div>
                <span>Target Goal</span>
            </div>
        </div>
    </div>

    <button id="btn-reset">Reset Simulation</button>
</div>

<script>
/**
 * Simple Warren Control Law Demo
 * Engine: 2D Kinematics with constant drift
 */

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

// State
let agent = { x: 50, y: 300, angle: 0 }; // Angle 0 = Right
let goal = { x: 600, y: 300 };
let path = [];

// Params
let W = 0;       // Flow Weight
let DRIFT = 0.8; // Y-axis drift speed
const SPEED = 2; // Forward speed
const K = 0.05;  // Turning stiffness

// Loop
let animationId;

function init() {
    resize();
    reset();
    loop();
}

function reset() {
    // Start on left, goal on right
    agent.x = 50;
    agent.y = canvas.height / 2;
    agent.angle = 0; // Facing right
    goal.x = canvas.width - 100;
    goal.y = canvas.height / 2;
    path = [];
}

function update() {
    // 1. Calculate Vectors
    const dx = goal.x - agent.x;
    const dy = goal.y - agent.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    // Stop if close
    if(dist < 10) return;

    // Goal Angle (Absolute)
    const goalAngle = Math.atan2(dy, dx);

    // 2. The Errors
    
    // Beta: Facing Error (Where is goal relative to nose?)
    // Normalize to -PI to PI
    let beta = normalizeAngle(agent.angle - goalAngle);

    // Alpha: Path Error (Where is goal relative to actual movement?)
    // Actual velocity vector = Forward(v) + Drift
    // Vx = Speed * cos(angle)
    // Vy = Speed * sin(angle) + DRIFT
    const vx = SPEED * Math.cos(agent.angle);
    const vy = SPEED * Math.sin(agent.angle) + DRIFT;
    const pathAngle = Math.atan2(vy, vx); // The direction we are ACTUALLY moving
    
    let alpha = normalizeAngle(pathAngle - goalAngle);

    // 3. Warren's Law
    // dPhi = -k ( beta + w * alpha )
    // Note: In paper w is multiplied by speed, here we bundle it for simplicity
    const turn = -K * (beta + (W * alpha));

    // 4. Move
    agent.angle += turn;
    agent.x += vx;
    agent.y += vy;

    // History
    if(path.length === 0 || distSq(agent, path[path.length-1]) > 100) {
        path.push({x: agent.x, y: agent.y});
    }
}

function draw() {
    // Clear
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Drift Arrows (Background)
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 1;
    const gridSize = 50;
    for(let x=0; x<canvas.width; x+=gridSize) {
        for(let y=0; y<canvas.height; y+=gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + (DRIFT * 10)); // Visualize drift direction
            ctx.stroke();
        }
    }

    // Draw Goal
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(goal.x, goal.y, 10, 0, Math.PI*2);
    ctx.fill();

    // Draw Path Trace
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 2;
    ctx.beginPath();
    if(path.length > 0) {
        ctx.moveTo(path[0].x, path[0].y);
        for(let p of path) ctx.lineTo(p.x, p.y);
        ctx.lineTo(agent.x, agent.y);
    }
    ctx.stroke();

    // Draw Agent
    ctx.save();
    ctx.translate(agent.x, agent.y);
    
    // 1. Draw Actual Path Vector (Flow)
    const vx = SPEED * Math.cos(agent.angle);
    const vy = SPEED * Math.sin(agent.angle) + DRIFT;
    const pathAngle = Math.atan2(vy, vx);
    
    ctx.rotate(pathAngle);
    ctx.fillStyle = '#00d4ff'; // Accent
    ctx.globalAlpha = 0.3 + (W/10)*0.7; // Brightness depends on weight
    ctx.beginPath();
    ctx.moveTo(0, -5); ctx.lineTo(40, 0); ctx.lineTo(0, 5);
    ctx.fill();
    ctx.rotate(-pathAngle); // Reset

    // 2. Draw Facing Vector (Nose)
    ctx.rotate(agent.angle);
    ctx.fillStyle = '#ff9f43'; // Secondary
    ctx.globalAlpha = 1.0;
    ctx.beginPath();
    // Triangle
    ctx.moveTo(-10, -10);
    ctx.lineTo(15, 0);
    ctx.lineTo(-10, 10);
    ctx.fill();

    ctx.restore();
}

function loop() {
    update();
    draw();
    animationId = requestAnimationFrame(loop);
}

// Helpers
function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI*2;
    while (a < -Math.PI) a += Math.PI*2;
    return a;
}
function distSq(p1, p2) {
    return (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
}

// Inputs
function resize() {
    canvas.width = window.innerWidth - 320; // Sidebar width
    canvas.height = window.innerHeight;
    reset();
}
window.addEventListener('resize', resize);

document.getElementById('slider-w').oninput = (e) => {
    W = parseFloat(e.target.value);
    document.getElementById('val-w').innerText = W.toFixed(1);
    // Don't reset, let user change mid-flight!
};
document.getElementById('slider-drift').oninput = (e) => {
    DRIFT = parseFloat(e.target.value);
    document.getElementById('val-drift').innerText = DRIFT.toFixed(1);
};
document.getElementById('btn-reset').onclick = reset;

// Move Goal on Click
canvas.addEventListener('mousedown', (e) => {
    goal.x = e.clientX;
    goal.y = e.clientY;
});

// Start
init();

</script>
</body>
</html>